// Relation declarations
.decl *target(t: uint)
.decl *beneficiary(p: address)
.decl *owner(p: address)
.decl *raised(n: uint)
.decl constructor(t: uint, b: address)

// Transactions
.decl recv_close()
.decl *close(v: bool)
.decl recv_invest()
.decl invest(p: address, n: uint)
.decl recv_refund()
.decl refund(p: address, n: uint)
.decl recv_withdraw()
.decl withdraw(p: address, n:uint)

.decl *closed(b: bool)

// Interfaces
.public recv_close
.public recv_invest
.public recv_refund
.public recv_withdraw
.public closed(0)
.public raised(0)

beneficiary(p) :- constructor(_, p).
target(t) :- constructor(t,_).
// Record the contract owner at construction time (simplified)
owner(p) :- constructor(_,_), msgSender(p).
raised(0) :- constructor(_,_).

// Views
raised(s) :- s = sum m: invest(_, m).

.decl investTotal(p: address, n: uint)[0]
.decl refundTotal(p: address, n: uint)[0]
.decl balanceOf(p: address, n: uint)[0]
.decl totalBalance(n: uint)[0]
investTotal(p,s) :- invest(p, _), s = sum m: invest(p,m).
refundTotal(p,s) :- refund(p, _), s = sum m: refund(p,m).
balanceOf(p,s) :- investTotal(p,i), refundTotal(p,r), s := i-r.
// Total balance equals the sum of all individual balances
totalBalance(n) :- n = sum s: balanceOf(_, s).

// Transaction conditions (aligned with benchmarks/crowFunding.dl)
// Invest only when not closed and before reaching target
invest(p, n) :- recv_invest(), msgSender(p), msgValue(n), closed(false),
    raised(s), target(t), s < t.

// Close: only owner can close (benchmarks semantics)
closed(true) :- recv_close(), msgSender(s), owner(s).

// Refund: when closed is true and raised < target; refund all balance
refund(p, n) :- recv_refund(), msgSender(p), closed(true),
            raised(r), target(t), r < t,
            balanceOf(p, n), n > 0.

// Withdraw: beneficiary can withdraw when raised >= target
withdraw(p, r) :- recv_withdraw(), msgSender(p), beneficiary(p),
            raised(r), target(t), r >= t.